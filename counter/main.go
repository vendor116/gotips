package main

import (
	"context"
	"log"
	"runtime"
	"sync"
)

// ValueRequest Структура запроса для получения текущего значения счетчика.
// Включает канал ответа для отправки значения обратно вызывающей стороне.
type ValueRequest struct {
	ResponseCh chan int
}

// Counter управляет внутренним состоянием счета безопасным, конкурентным способом,
// используя принцип Go "взаимодействующие последовательные процессы" (CSP).
type Counter struct {
	// Канал для отправки команд увеличения
	incCh chan int
	// Канал для отправки запросов на получение значения (ValueRequest)
	valueCh chan ValueRequest
}

// NewCounter инициализирует и запускает горутину, которая владеет и управляет состоянием счетчика.
func NewCounter(ctx context.Context) *Counter {
	// Небуферизованные каналы идеально подходят для синхронизации операций
	incCh := make(chan int)
	valueCh := make(chan ValueRequest)

	c := &Counter{
		incCh:   incCh,
		valueCh: valueCh,
	}

	// Запускаем единственную горутину-"владельца" для управления общим состоянием (n)
	go c.run(ctx)

	return c
}

// run — это единственная горутина, которая управляет переменной состояния 'n'.
// Все модификации и чтения должны проходить через этот цикл.
func (c *Counter) run(ctx context.Context) {
	var n int

	// Выводим напоминание о запущенной горутине
	log.Printf("[Счетчик] Запуск горутины-владельца состояния...\n")

	for {
		select {
		// Случай 1: Получение команды увеличения от Inc()
		case v := <-c.incCh:
			n += v

		// Случай 2: Получение запроса на чтение значения от Value()
		case req := <-c.valueCh:
			// Отправляем текущее значение обратно по выделенному каналу ответа
			// Это блокирует до тех пор, пока вызывающая сторона не прочитает значение, обеспечивая синхронное чтение.
			req.ResponseCh <- n

		// Случай 3: Отмена контекста
		case <-ctx.Done():
			log.Printf("[Счетчик] Остановка горутины-владельца состояния. Финальный счет: %d\n", n)
			return
		}
	}
}

// Inc отправляет команду увеличения горутине-владельцу состояния.
// Это синхронная отправка, гарантирующая, что команда будет получена владельцем.
func (c *Counter) Inc() {
	c.incCh <- 1
}

// Value извлекает текущее значение счетчика, используя шаблон "запрос-ответ".
func (c *Counter) Value() int {
	// 1. Создаем канал для получения ответа
	respCh := make(chan int)

	// 2. Отправляем запрос (который содержит канал ответа) владельцу
	c.valueCh <- ValueRequest{ResponseCh: respCh}

	// 3. Блокируем и ждем, пока горутина-владелец отправит значение обратно
	return <-respCh
}

func main() {
	// Устанавливаем количество потоков/ЦПУ для использования
	runtime.GOMAXPROCS(runtime.NumCPU())

	// Используем фоновый контекст, так как мы не планируем отменять этот недолговечный счетчик
	ctx := context.Background()
	c := NewCounter(ctx)

	const increments = 10
	var wg sync.WaitGroup

	log.Printf("Запуск %d одновременных увеличений...\n", increments)

	for i := range increments {
		wg.Add(1) // Сигнализируем о запуске новой горутины

		// Используем стандартную горутину
		go func(i int) {
			defer wg.Done() // Сигнализируем о завершении этой горутины
			c.Inc()
			log.Printf("Горутина %d увеличила счетчик.\n", i)
		}(i)
	}

	wg.Wait() // Ждем завершения вызова Inc() всеми 10 горутинами

	// Получаем финальное значение
	finalValue := c.Value()

	log.Printf("Все горутины завершены.\n")
	log.Printf("Ожидаемое значение: %d\n", increments)
	log.Printf("Фактическое значение: %d\n", finalValue)
}
